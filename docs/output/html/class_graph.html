<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Travelling Groups: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Travelling Groups<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Unidade Curricular DA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae4c72b8ac4d693c49800a4c7e273654f">Graph</a> ()</td></tr>
<tr class="separator:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284b99bdb07994225dee3c2cdb59c80a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a284b99bdb07994225dee3c2cdb59c80a">Graph</a> (int <a class="el" href="class_graph.html#a71b5e16eb9e0670fea3ecee3526abb41">nodes</a>)</td></tr>
<tr class="separator:a284b99bdb07994225dee3c2cdb59c80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3157a04ab5d808f5bc15823827c744e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac3157a04ab5d808f5bc15823827c744e">addEdge</a> (int src, int dest, int capacity, int duration)</td></tr>
<tr class="separator:ac3157a04ab5d808f5bc15823827c744e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e88fd9acca448bb1cd31419a3e7c1c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4e88fd9acca448bb1cd31419a3e7c1c8">changeCapacity</a> (vector&lt; pair&lt; int, int &gt; &gt; &amp;q, int node, int capacity) const</td></tr>
<tr class="separator:a4e88fd9acca448bb1cd31419a3e7c1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c7aa963c5606b264196307481a37b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af9c7aa963c5606b264196307481a37b1">maxCapacity</a> (int src, int dest)</td></tr>
<tr class="separator:af9c7aa963c5606b264196307481a37b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473e9c668e4756fc8a737c8b16e29fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a473e9c668e4756fc8a737c8b16e29fa7">minTranshipments</a> (int src, int dest)</td></tr>
<tr class="separator:a473e9c668e4756fc8a737c8b16e29fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a78379ceca39ea0a506fca06403f7e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0a78379ceca39ea0a506fca06403f7e0">bfsCapacity</a> (const int &amp;source, const int &amp;target)</td></tr>
<tr class="separator:a0a78379ceca39ea0a506fca06403f7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae083252494afbae69c1107bc06fa2a36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae083252494afbae69c1107bc06fa2a36">getPathMaxCapacity</a> (const vector&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:ae083252494afbae69c1107bc06fa2a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bb3bcabb2ca62a98fc9834addf0c74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab7bb3bcabb2ca62a98fc9834addf0c74">getMaxFlow</a> (const int &amp;source, const int &amp;destination, <a class="el" href="class_graph.html">Graph</a> &amp;network)</td></tr>
<tr class="separator:ab7bb3bcabb2ca62a98fc9834addf0c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89737876a42136f201609abd2cd4c9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a89737876a42136f201609abd2cd4c9be">increaseRevCapacity</a> (const int &amp;a, const int &amp;b, const int &amp;capacity)</td></tr>
<tr class="separator:a89737876a42136f201609abd2cd4c9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beabf9cc3e7e5a62ffa70f6282f0ba7"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3beabf9cc3e7e5a62ffa70f6282f0ba7">getPath</a> (const int &amp;source, const int &amp;destination, int &amp;<a class="el" href="class_graph.html#af9c7aa963c5606b264196307481a37b1">maxCapacity</a>)</td></tr>
<tr class="separator:a3beabf9cc3e7e5a62ffa70f6282f0ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7827b4bc053ebe9528c67f232ecd8a0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7827b4bc053ebe9528c67f232ecd8a0a">getAllPaths</a> (const int &amp;source, const int &amp;target, vector&lt; pair&lt; vector&lt; int &gt;, int &gt; &gt; &amp;result)</td></tr>
<tr class="separator:a7827b4bc053ebe9528c67f232ecd8a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac442361cc88da48f68acfcc893224016"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac442361cc88da48f68acfcc893224016">separateGroup</a> (const int &amp;src, const int &amp;target, int dimension, <a class="el" href="class_graph.html">Graph</a> &amp;network, int extra=0)</td></tr>
<tr class="separator:ac442361cc88da48f68acfcc893224016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac526563ef51138bbcbd1974879730824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac526563ef51138bbcbd1974879730824">initializeResidualNetwork</a> (vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt; &amp;residualNetwork) const</td></tr>
<tr class="separator:ac526563ef51138bbcbd1974879730824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f86a2520170a141d1d29380bbb8f19a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3f86a2520170a141d1d29380bbb8f19a">findResidualNetworkPath</a> (int src, int dest, vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt; &amp;residualNetwork) const</td></tr>
<tr class="separator:a3f86a2520170a141d1d29380bbb8f19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a2b0e1e03b04e60ea02d8835d741a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a03a2b0e1e03b04e60ea02d8835d741a7">getMaxFlow</a> (int src, int dest)</td></tr>
<tr class="separator:a03a2b0e1e03b04e60ea02d8835d741a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a213478bb8fb42bc2dd72def192f0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af3a213478bb8fb42bc2dd72def192f0c">reuniteGroup</a> (int source, int dest, vector&lt; vector&lt; int &gt; &gt; paths) const</td></tr>
<tr class="separator:af3a213478bb8fb42bc2dd72def192f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36b82a0e2c5fd6d9ca97d5be30802d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad36b82a0e2c5fd6d9ca97d5be30802d4">waitTime</a> (int source, int reunite, const vector&lt; vector&lt; int &gt; &gt; &amp;paths) const</td></tr>
<tr class="separator:ad36b82a0e2c5fd6d9ca97d5be30802d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a32ddc59a57254f088cfe51c2c931a091"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a32ddc59a57254f088cfe51c2c931a091">comparePaths</a> (const pair&lt; vector&lt; int &gt;, int &gt; &amp;p1, const pair&lt; vector&lt; int &gt;, int &gt; &amp;p2)</td></tr>
<tr class="separator:a32ddc59a57254f088cfe51c2c931a091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09a0b432e5040b25f5905fdd70f2805"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad09a0b432e5040b25f5905fdd70f2805">printPath</a> (const vector&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:ad09a0b432e5040b25f5905fdd70f2805"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a81a76a428e630453ef019a15b9092967"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a81a76a428e630453ef019a15b9092967">n</a></td></tr>
<tr class="separator:a81a76a428e630453ef019a15b9092967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a71b5e16eb9e0670fea3ecee3526abb41">nodes</a></td></tr>
<tr class="separator:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c72b8ac4d693c49800a4c7e273654f" name="ae4c72b8ac4d693c49800a4c7e273654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c72b8ac4d693c49800a4c7e273654f">&#9670;&nbsp;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor: default. </p>

</div>
</div>
<a id="a284b99bdb07994225dee3c2cdb59c80a" name="a284b99bdb07994225dee3c2cdb59c80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284b99bdb07994225dee3c2cdb59c80a">&#9670;&nbsp;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor: nr nodes and direction (default: undirected). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac3157a04ab5d808f5bc15823827c744e" name="ac3157a04ab5d808f5bc15823827c744e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3157a04ab5d808f5bc15823827c744e">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add an edge from a source stop to a destination stop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>is the source stop. </td></tr>
    <tr><td class="paramname">dest</td><td>is the destinations stop. </td></tr>
    <tr><td class="paramname">capacity</td><td>is the maximum number of people that can be transported. </td></tr>
    <tr><td class="paramname">duration</td><td>is the travel time between two stops. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a78379ceca39ea0a506fca06403f7e0" name="a0a78379ceca39ea0a506fca06403f7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a78379ceca39ea0a506fca06403f7e0">&#9670;&nbsp;</a></span>bfsCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::bfsCapacity </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >BFS algorithm implementation used to find a path from a source node to a destination node and the capacity of each stop in that that path. </p><dl class="section return"><dt>Returns</dt><dd>true if there is path from the source to the destination stop, else false. </dd></dl>

</div>
</div>
<a id="a4e88fd9acca448bb1cd31419a3e7c1c8" name="a4e88fd9acca448bb1cd31419a3e7c1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e88fd9acca448bb1cd31419a3e7c1c8">&#9670;&nbsp;</a></span>changeCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::changeCapacity </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Updates the capacity of a certain node in a vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>vector to update capacity. </td></tr>
    <tr><td class="paramname">node</td><td>number of the node whose capacity needs to be updated. </td></tr>
    <tr><td class="paramname">capacity</td><td>new capacity of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ddc59a57254f088cfe51c2c931a091" name="a32ddc59a57254f088cfe51c2c931a091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ddc59a57254f088cfe51c2c931a091">&#9670;&nbsp;</a></span>comparePaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::comparePaths </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; vector&lt; int &gt;, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; vector&lt; int &gt;, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compares paths in descending order according to their capacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>path 1. </td></tr>
    <tr><td class="paramname">p2</td><td>path 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if p1 is greater than p2, else returns false. </dd></dl>

</div>
</div>
<a id="a3f86a2520170a141d1d29380bbb8f19a" name="a3f86a2520170a141d1d29380bbb8f19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f86a2520170a141d1d29380bbb8f19a">&#9670;&nbsp;</a></span>findResidualNetworkPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::findResidualNetworkPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residualNetwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finds the shortest path from a source node to a destination node in the residual network, if a path exists.<br  />
BFS algorithm, used to determine shortest path from one node to another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>is the source bus stop. </td></tr>
    <tr><td class="paramname">dest</td><td>is the destination bus stop. </td></tr>
    <tr><td class="paramname">residualNetwork</td><td>is the residual network of the curretn network being analized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shortest path from src to dest in the residual network. If there isn't a path, a vector with size 1 is returned. </dd></dl>

</div>
</div>
<a id="a7827b4bc053ebe9528c67f232ecd8a0a" name="a7827b4bc053ebe9528c67f232ecd8a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7827b4bc053ebe9528c67f232ecd8a0a">&#9670;&nbsp;</a></span>getAllPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::getAllPaths </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; vector&lt; int &gt;, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes all possible paths from a source node to a destination node using BFS. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>is the source bus stop. </td></tr>
    <tr><td class="paramname">target</td><td>is the destination bus stop. </td></tr>
    <tr><td class="paramname">result</td><td>is a vector that will be updated with all the paths from source to destination and the capacity of each one of these paths. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7bb3bcabb2ca62a98fc9834addf0c74" name="ab7bb3bcabb2ca62a98fc9834addf0c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bb3bcabb2ca62a98fc9834addf0c74">&#9670;&nbsp;</a></span>getMaxFlow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getMaxFlow </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>network</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Implementation of Edmounds-Karp algorithm to compute the maximum flow of a network, i.e., the maximum number of people that can be transported, in each iteration, from a source to a destination stop, using all possible paths. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>is the source bus stop. </td></tr>
    <tr><td class="paramname">destination</td><td>is the destination bus stop. </td></tr>
    <tr><td class="paramname">network</td><td>is the network whose maximum flow will be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum flow of network. </dd></dl>

</div>
</div>
<a id="a03a2b0e1e03b04e60ea02d8835d741a7" name="a03a2b0e1e03b04e60ea02d8835d741a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a2b0e1e03b04e60ea02d8835d741a7">&#9670;&nbsp;</a></span>getMaxFlow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::getMaxFlow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finds the maximum flow in the transportation network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>is the src bus stop. </td></tr>
    <tr><td class="paramname">dest</td><td>is the destination bus stop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3beabf9cc3e7e5a62ffa70f6282f0ba7" name="a3beabf9cc3e7e5a62ffa70f6282f0ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3beabf9cc3e7e5a62ffa70f6282f0ba7">&#9670;&nbsp;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::getPath </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>maxCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes te path from a source node to a destination node according to the "prev" field previously updated by the BFS algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>is the source bus stop. </td></tr>
    <tr><td class="paramname">destination</td><td>is the destination bus stop. </td></tr>
    <tr><td class="paramname">maxCapacity</td><td>is the path capacity that will be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae083252494afbae69c1107bc06fa2a36" name="ae083252494afbae69c1107bc06fa2a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae083252494afbae69c1107bc06fa2a36">&#9670;&nbsp;</a></span>getPathMaxCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getPathMaxCapacity </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the maximum capacity of a path according to its edges flow, i.e, the minimum of its edges flow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>is the path whose capacity will be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the path capacity. </dd></dl>

</div>
</div>
<a id="a89737876a42136f201609abd2cd4c9be" name="a89737876a42136f201609abd2cd4c9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89737876a42136f201609abd2cd4c9be">&#9670;&nbsp;</a></span>increaseRevCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::increaseRevCapacity </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Auxiliary function to Edmounds-Karp algorithm that increases the capacity of the reverse edge from a node a to another node b (i.e., the edge from b to a), by a number of units equal the capacity of the path being considered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the source stop. </td></tr>
    <tr><td class="paramname">b</td><td>is the destination stop. </td></tr>
    <tr><td class="paramname">capacity</td><td>is the capacity to be added to the edge b -&gt; a. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac526563ef51138bbcbd1974879730824" name="ac526563ef51138bbcbd1974879730824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac526563ef51138bbcbd1974879730824">&#9670;&nbsp;</a></span>initializeResidualNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::initializeResidualNetwork </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residualNetwork</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initializes the residual network of the current network being used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">residualNetwork</td><td>is the graph to be initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9c7aa963c5606b264196307481a37b1" name="af9c7aa963c5606b264196307481a37b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c7aa963c5606b264196307481a37b1">&#9670;&nbsp;</a></span>maxCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::maxCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given an origin and a destination, finds the path with maximum capacity in a transportation network.<br  />
Variation of Dijkstra's algorithm, used to find the maximum capacity of a <a class="el" href="class_graph.html">Graph</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>is the source stop. </td></tr>
    <tr><td class="paramname">dest</td><td>is the destination stop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a473e9c668e4756fc8a737c8b16e29fa7" name="a473e9c668e4756fc8a737c8b16e29fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473e9c668e4756fc8a737c8b16e29fa7">&#9670;&nbsp;</a></span>minTranshipments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::minTranshipments </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given an origin and a destination, finds the path with minimum transhipments, i.e minimum bus changes (shortest path).<br  />
BFS algorithm, used to determine shortest path from one node to another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>is the source stop. </td></tr>
    <tr><td class="paramname">dest</td><td>is the destinations stop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad09a0b432e5040b25f5905fdd70f2805" name="ad09a0b432e5040b25f5905fdd70f2805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09a0b432e5040b25f5905fdd70f2805">&#9670;&nbsp;</a></span>printPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::printPath </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Auxiliary method to display a path in a user-friendly way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>is the path that will be displayed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3a213478bb8fb42bc2dd72def192f0c" name="af3a213478bb8fb42bc2dd72def192f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a213478bb8fb42bc2dd72def192f0c">&#9670;&nbsp;</a></span>reuniteGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::reuniteGroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finds the earliest stop where every group will be able to reunite. In the worst case, this happens in the destination stop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>is the source bus stop. </td></tr>
    <tr><td class="paramname">dest</td><td>is the destination bus stop. </td></tr>
    <tr><td class="paramname">paths</td><td>is a vector of the paths being taken by each group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac442361cc88da48f68acfcc893224016" name="ac442361cc88da48f68acfcc893224016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac442361cc88da48f68acfcc893224016">&#9670;&nbsp;</a></span>separateGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; int &gt; &gt; Graph::separateGroup </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extra</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the path that a group with a certain dimension should follow to reach their destination. If necessary, the group can be divided in sub groups. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>is the source stop. </td></tr>
    <tr><td class="paramname">target</td><td>is the destination stop. </td></tr>
    <tr><td class="paramname">dimension</td><td>is the dimension of the group. </td></tr>
    <tr><td class="paramname">network</td><td>is the network with all stops and the buses (edges) that connect these stops. </td></tr>
    <tr><td class="paramname">extra</td><td>is the dimension of an additional group whose path should be calculated after computing the original group path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad36b82a0e2c5fd6d9ca97d5be30802d4" name="ad36b82a0e2c5fd6d9ca97d5be30802d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36b82a0e2c5fd6d9ca97d5be30802d4">&#9670;&nbsp;</a></span>waitTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::waitTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reunite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculates how much time each group will have to wait at the meeting stop. Every group must wait for the last group to arrive. The last group to arrive will wait for 0 min. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>is the source bus stop. </td></tr>
    <tr><td class="paramname">reunite</td><td>is the destination bus stop. </td></tr>
    <tr><td class="paramname">paths</td><td>is a vector of the paths being taken by each group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a81a76a428e630453ef019a15b9092967" name="a81a76a428e630453ef019a15b9092967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a76a428e630453ef019a15b9092967">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::n</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Network size. Stops are numbered from 1 to n. </p>

</div>
</div>
<a id="a71b5e16eb9e0670fea3ecee3526abb41" name="a71b5e16eb9e0670fea3ecee3526abb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b5e16eb9e0670fea3ecee3526abb41">&#9670;&nbsp;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="struct_graph_1_1_node.html">Node</a>&gt; Graph::nodes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >List of stops being represented. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/isabe/OneDrive/Ambiente de Trabalho/FEUP/2_Ano/2_Semestre/DA/Projeto2/feup-da-TravellingGroups/src/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>C:/Users/isabe/OneDrive/Ambiente de Trabalho/FEUP/2_Ano/2_Semestre/DA/Projeto2/feup-da-TravellingGroups/src/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
